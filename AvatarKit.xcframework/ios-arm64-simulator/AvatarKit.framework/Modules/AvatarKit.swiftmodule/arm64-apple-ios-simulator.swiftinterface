// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.1 (swiftlang-6.2.1.4.8 clang-1700.4.4.1)
// swift-module-flags: -target arm64-apple-ios16.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 6 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -module-name AvatarKit
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.1
import AVFAudio
import Accelerate
import CoreML
import Foundation
import Metal
import MetalKit
import QuartzCore
import Swift
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os
import simd
public struct Avatar : Swift.Sendable {
  public let id: Swift.String
}
@_hasMissingDesignatedInitializers @_Concurrency.MainActor final public class AvatarController {
  @_Concurrency.MainActor final public var onConnectionState: ((AvatarKit.ConnectionState) -> Swift.Void)?
  @_Concurrency.MainActor final public var onConversationState: ((AvatarKit.ConversationState) -> Swift.Void)?
  @_Concurrency.MainActor final public var onError: ((AvatarKit.AvatarError) -> Swift.Void)?
  @_Concurrency.MainActor final public func start()
  @discardableResult
  @_Concurrency.MainActor final public func send(_ audioData: Foundation.Data, end: Swift.Bool = false) -> Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor final public func yield(_ audioData: Foundation.Data, end: Swift.Bool = false, audioFormat: AvatarKit.AudioFormat? = nil) -> Swift.String
  #endif
  @_Concurrency.MainActor final public func yield(_ animations: [Foundation.Data], conversationID: Swift.String)
  @_Concurrency.MainActor final public func interrupt()
  @_Concurrency.MainActor final public func close()
  @_Concurrency.MainActor final public var volume: Swift.Float {
    get
    set
  }
  @objc deinit
}
public typealias ProgressHandler = @_Concurrency.MainActor @Sendable (Foundation.Progress) -> Swift.Void
@_hasMissingDesignatedInitializers final public class AvatarManager : Swift.Sendable {
  public static let shared: AvatarKit.AvatarManager
  #if compiler(>=5.3) && $NonescapableTypes
  final public func retrieve(id: Swift.String) -> AvatarKit.Avatar?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func load(id: Swift.String, onProgress progressHandler: AvatarKit.ProgressHandler? = nil) async throws -> AvatarKit.Avatar
  #endif
  final public func clear(id: Swift.String) throws
  final public func clearAll() throws
  final public func clearLRU(keepCount: Swift.Int) throws
  final public func getCacheSize(id: Swift.String) throws -> Swift.Int
  final public func getAllCacheSize() throws -> Swift.Int
  @objc deinit
}
@_Concurrency.MainActor public enum AvatarSDK {
  @_Concurrency.MainActor public static var appID: Swift.String {
    get
  }
  @_Concurrency.MainActor public static var configuration: AvatarKit.Configuration {
    get
  }
  @_Concurrency.MainActor public static func initialize(appID: Swift.String, configuration: AvatarKit.Configuration)
  @_Concurrency.MainActor public static var sessionToken: Swift.String
  @_Concurrency.MainActor public static var userID: Swift.String
  @_Concurrency.MainActor public static var version: Swift.String {
    get
  }
  @_Concurrency.MainActor public static var supportsCurrentDevice: Swift.Bool {
    get
  }
  @_Concurrency.MainActor public static func benchmark() async -> Swift.Int
}
public struct Configuration : Swift.Equatable, Swift.Sendable {
  public let environment: AvatarKit.Environment
  public let audioFormat: AvatarKit.AudioFormat
  public let drivingServiceMode: AvatarKit.DrivingServiceMode
  public let logLevel: AvatarKit.LogLevel
  public init(environment: AvatarKit.Environment, audioFormat: AvatarKit.AudioFormat = .init(), drivingServiceMode: AvatarKit.DrivingServiceMode = .sdk, logLevel: AvatarKit.LogLevel = .off)
  public static func == (a: AvatarKit.Configuration, b: AvatarKit.Configuration) -> Swift.Bool
}
public enum Environment : Swift.String, Swift.Sendable {
  case intl
  case cn
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct AudioFormat : Swift.Equatable, Swift.Sendable {
  public let channelCount: Swift.Int
  public let sampleRate: Swift.Int
  public init(sampleRate: Swift.Int = 16000)
  public static func == (a: AvatarKit.AudioFormat, b: AvatarKit.AudioFormat) -> Swift.Bool
}
public enum DrivingServiceMode : Swift.String, Swift.Sendable {
  case sdk
  case host
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum LogLevel : Swift.String, Swift.Sendable {
  case off
  case error
  case warning
  case all
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ConnectionState : Swift.Sendable {
  case disconnected
  case connecting
  case connected
  case failed(any Swift.Error)
}
public enum ConversationState : Swift.String, Swift.Sendable {
  case idle
  case paused
  case playing
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct Transform : Swift.Equatable, Swift.Sendable {
  public static let identity: AvatarKit.Transform
  public let x: Swift.Float
  public let y: Swift.Float
  public let scale: Swift.Float
  public init(x: Swift.Float = 0.0, y: Swift.Float = 0.0, scale: Swift.Float = 1.0)
  public static func == (a: AvatarKit.Transform, b: AvatarKit.Transform) -> Swift.Bool
}
public enum AvatarError : Swift.String, Foundation.LocalizedError {
  case appIDUnrecognized
  case avatarIDUnrecognized
  case sessionTokenInvalid
  case sessionTokenExpired
  case failedToFetchAvatarMetadata
  case failedToDownloadAvatarAssets
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var failureReason: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency final public class AvatarView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency final public let avatarController: AvatarKit.AvatarController
  @_Concurrency.MainActor @preconcurrency public init(avatar: AvatarKit.Avatar)
  @_Concurrency.MainActor @preconcurrency @objc override final public func didMoveToWindow()
  @_Concurrency.MainActor @preconcurrency @objc override final public var isOpaque: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency final public var contentTransform: AvatarKit.Transform {
    get
    set
  }
  @objc deinit
}
public protocol BitPatternRepresentible {
  associatedtype BitPattern
  var bitPattern: Self.BitPattern { get }
  init(bitPattern: Self.BitPattern)
}
extension Swift.Float : AvatarKit.BitPatternRepresentible {
  public typealias BitPattern = Swift.UInt32
}
extension Swift.Double : AvatarKit.BitPatternRepresentible {
  public typealias BitPattern = Swift.UInt64
}
public protocol ByteWidthProviding {
  static var byteWidth: Swift.Int { get }
}
extension Swift.BinaryInteger {
  public static var byteWidth: Swift.Int {
    get
  }
}
extension Swift.BinaryFloatingPoint {
  public static var byteWidth: Swift.Int {
    get
  }
}
extension Swift.Int8 : AvatarKit.ByteWidthProviding {
}
extension Swift.UInt8 : AvatarKit.ByteWidthProviding {
}
extension Swift.Int16 : AvatarKit.ByteWidthProviding {
}
extension Swift.UInt16 : AvatarKit.ByteWidthProviding {
}
extension Swift.Int32 : AvatarKit.ByteWidthProviding {
}
extension Swift.UInt32 : AvatarKit.ByteWidthProviding {
}
extension Swift.Int64 : AvatarKit.ByteWidthProviding {
}
extension Swift.UInt64 : AvatarKit.ByteWidthProviding {
}
extension Swift.Float : AvatarKit.ByteWidthProviding {
}
extension Swift.Double : AvatarKit.ByteWidthProviding {
}
public protocol DataConvertible {
  init<D>(_ data: D, from offset: D.Index, bigEndian: Swift.Bool) where D : Foundation.DataProtocol
  init<D>(_ data: D, bigEndian: Swift.Bool) where D : Foundation.DataProtocol
  static func array<D>(_ data: D, from offset: D.Index, count: Swift.Int, bigEndian: Swift.Bool) -> [Self] where D : Foundation.DataProtocol
  static func array<D>(_ data: D, count: Swift.Int, bigEndian: Swift.Bool) -> [Self] where D : Foundation.DataProtocol
}
public protocol ZeroProviding {
  static var zero: Self { get }
}
extension Swift.BinaryInteger where Self : AvatarKit.DataConvertible, Self : AvatarKit.EndianConvertible {
  public init<D>(_ data: D, from offset: D.Index, bigEndian: Swift.Bool) where D : Foundation.DataProtocol
  public init<D>(_ data: D, bigEndian: Swift.Bool) where D : Foundation.DataProtocol
  public static func array<D>(_ data: D, from offset: D.Index, count: Swift.Int, bigEndian: Swift.Bool) -> [Self] where D : Foundation.DataProtocol
  public static func array<D>(_ data: D, count: Swift.Int, bigEndian: Swift.Bool) -> [Self] where D : Foundation.DataProtocol
}
extension Swift.BinaryFloatingPoint where Self : AvatarKit.BitPatternRepresentible, Self : AvatarKit.DataConvertible, Self.BitPattern : AvatarKit.EndianConvertible, Self.BitPattern : AvatarKit.ZeroProviding {
  public init<D>(_ data: D, from offset: D.Index, bigEndian: Swift.Bool) where D : Foundation.DataProtocol
  public init<D>(_ data: D, bigEndian: Swift.Bool) where D : Foundation.DataProtocol
  public static func array<D>(_ data: D, from offset: D.Index, count: Swift.Int, bigEndian: Swift.Bool) -> [Self] where D : Foundation.DataProtocol
  public static func array<D>(_ data: D, count: Swift.Int, bigEndian: Swift.Bool) -> [Self] where D : Foundation.DataProtocol
}
extension Swift.Int8 : AvatarKit.DataConvertible {
}
extension Swift.UInt8 : AvatarKit.DataConvertible {
}
extension Swift.Int16 : AvatarKit.DataConvertible {
}
extension Swift.UInt16 : AvatarKit.DataConvertible {
}
extension Swift.Int32 : AvatarKit.DataConvertible {
}
extension Swift.UInt32 : AvatarKit.DataConvertible, AvatarKit.ZeroProviding {
}
extension Swift.Int64 : AvatarKit.DataConvertible {
}
extension Swift.UInt64 : AvatarKit.DataConvertible, AvatarKit.ZeroProviding {
}
extension Swift.Float : AvatarKit.DataConvertible {
}
extension Swift.Double : AvatarKit.DataConvertible {
}
public protocol EndianConvertible {
  var byteSwapped: Self { get }
}
extension Swift.Int8 : AvatarKit.EndianConvertible {
}
extension Swift.UInt8 : AvatarKit.EndianConvertible {
}
extension Swift.Int16 : AvatarKit.EndianConvertible {
}
extension Swift.UInt16 : AvatarKit.EndianConvertible {
}
extension Swift.Int32 : AvatarKit.EndianConvertible {
}
extension Swift.UInt32 : AvatarKit.EndianConvertible {
}
extension Swift.Int64 : AvatarKit.EndianConvertible {
}
extension Swift.UInt64 : AvatarKit.EndianConvertible {
}
public struct PLYHeader : Swift.Equatable {
  public enum Format : Swift.String, Swift.Equatable {
    case ascii
    case binaryLittleEndian
    case binaryBigEndian
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct Element : Swift.Equatable, Swift.Sendable {
    public var name: Swift.String
    public var count: Swift.UInt32
    public var properties: [AvatarKit.PLYHeader.Property]
    #if compiler(>=5.3) && $NonescapableTypes
    public func index(forPropertyNamed name: Swift.String) -> Swift.Int?
    #endif
    public static func == (a: AvatarKit.PLYHeader.Element, b: AvatarKit.PLYHeader.Element) -> Swift.Bool
  }
  public enum PropertyType : Swift.Equatable, Swift.Sendable {
    case primitive(AvatarKit.PLYHeader.PrimitivePropertyType)
    case list(countType: AvatarKit.PLYHeader.PrimitivePropertyType, valueType: AvatarKit.PLYHeader.PrimitivePropertyType)
    public static func == (a: AvatarKit.PLYHeader.PropertyType, b: AvatarKit.PLYHeader.PropertyType) -> Swift.Bool
  }
  public enum PrimitivePropertyType : Swift.Equatable, Swift.Sendable {
    case int8
    case uint8
    case int16
    case uint16
    case int32
    case uint32
    case float32
    case float64
    public static func == (a: AvatarKit.PLYHeader.PrimitivePropertyType, b: AvatarKit.PLYHeader.PrimitivePropertyType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Property : Swift.Equatable, Swift.Sendable {
    public var name: Swift.String
    public var type: AvatarKit.PLYHeader.PropertyType
    public static func == (a: AvatarKit.PLYHeader.Property, b: AvatarKit.PLYHeader.Property) -> Swift.Bool
  }
  public var format: AvatarKit.PLYHeader.Format
  public var version: Swift.String
  public var elements: [AvatarKit.PLYHeader.Element]
  #if compiler(>=5.3) && $NonescapableTypes
  public func index(forElementNamed name: Swift.String) -> Swift.Int?
  #endif
  public static func == (a: AvatarKit.PLYHeader, b: AvatarKit.PLYHeader) -> Swift.Bool
}
extension AvatarKit.PLYHeader : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AvatarKit.PLYHeader.Element : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AvatarKit.PLYHeader.Property : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AvatarKit.PLYHeader.PropertyType : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AvatarKit.PLYHeader.PrimitivePropertyType : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol PLYReaderDelegate {
  func didStartReading(withHeader header: AvatarKit.PLYHeader)
  func didRead(element: AvatarKit.PLYElement, typeIndex: Swift.Int, withHeader elementHeader: AvatarKit.PLYHeader.Element)
  func didFinishReading()
  #if compiler(>=5.3) && $NonescapableTypes
  func didFailReading(withError error: (any Swift.Error)?)
  #endif
}
public class PLYReader {
  public enum Error : Foundation.LocalizedError {
    case cannotOpenSource(Foundation.URL)
    case readError(Foundation.URL)
    case headerStartMissing
    case headerEndMissing
    case headerFormatMissing
    case headerInvalidCharacters
    case headerUnknownKeyword(Swift.String)
    case headerUnexpectedKeyword(Swift.String)
    case headerInvalidLine(Swift.String)
    case headerInvalidFileFormatType(Swift.String)
    case headerUnknownPropertyType(Swift.String)
    case headerInvalidListCountType(Swift.String)
    case bodyInvalidStringForPropertyType(AvatarKit.PLYHeader.Element, Swift.Int, AvatarKit.PLYHeader.Property)
    case bodyMissingPropertyValuesInElement(AvatarKit.PLYHeader.Element, Swift.Int, AvatarKit.PLYHeader.Property)
    case bodyUnexpectedValuesInElement(AvatarKit.PLYHeader.Element, Swift.Int)
    case unexpectedEndOfFile(Foundation.URL)
    case internalConsistency
    #if compiler(>=5.3) && $NonescapableTypes
    public var errorDescription: Swift.String? {
      get
    }
    #endif
  }
  public init(_ url: Foundation.URL)
  public func read(to delegate: any AvatarKit.PLYReaderDelegate)
  @objc deinit
}
public struct PLYElement {
  public enum Property {
    case int8(Swift.Int8)
    case uint8(Swift.UInt8)
    case int16(Swift.Int16)
    case uint16(Swift.UInt16)
    case int32(Swift.Int32)
    case uint32(Swift.UInt32)
    case float32(Swift.Float)
    case float64(Swift.Double)
    case listInt8([Swift.Int8])
    case listUInt8([Swift.UInt8])
    case listInt16([Swift.Int16])
    case listUInt16([Swift.UInt16])
    case listInt32([Swift.Int32])
    case listUInt32([Swift.UInt32])
    case listFloat32([Swift.Float])
    case listFloat64([Swift.Double])
  }
  public var properties: [AvatarKit.PLYElement.Property]
}
public struct SplatScenePoint : Swift.Sendable {
  public enum Color : Swift.Sendable {
    case sphericalHarmonic(Swift.Float, Swift.Float, Swift.Float, [Swift.Float])
    case firstOrderSphericalHarmonic(Swift.Float, Swift.Float, Swift.Float)
    case linearFloat256(Swift.Float, Swift.Float, Swift.Float)
    case linearUInt8(Swift.UInt8, Swift.UInt8, Swift.UInt8)
  }
  public enum Opacity : Swift.Sendable {
    case logitFloat(Swift.Float)
    case linearFloat(Swift.Float)
    case linearUInt8(Swift.UInt8)
  }
  public enum Scale : Swift.Sendable {
    case exponent(Swift.Float, Swift.Float, Swift.Float)
    case linearFloat(Swift.Float, Swift.Float, Swift.Float)
  }
  public var position: Swift.SIMD3<Swift.Float>
  public var normal: Swift.SIMD3<Swift.Float>?
  public var color: AvatarKit.SplatScenePoint.Color
  public var opacity: AvatarKit.SplatScenePoint.Opacity
  public var scale: AvatarKit.SplatScenePoint.Scale
  public var rotation: simd.simd_quatf
  public var binding: Swift.Float32?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(position: Swift.SIMD3<Swift.Float>, normal: Swift.SIMD3<Swift.Float>?, color: AvatarKit.SplatScenePoint.Color, opacity: AvatarKit.SplatScenePoint.Opacity, scale: AvatarKit.SplatScenePoint.Scale, rotation: simd.simd_quatf, binding: Swift.Float32?)
  #endif
}
public protocol SplatSceneReaderDelegate : AnyObject {
  #if compiler(>=5.3) && $NonescapableTypes
  func didStartReading(withPointCount pointCount: Swift.UInt32?)
  #endif
  func didRead(points: [AvatarKit.SplatScenePoint])
  func didFinishReading()
  #if compiler(>=5.3) && $NonescapableTypes
  func didFailReading(withError error: (any Swift.Error)?)
  #endif
}
public protocol SplatSceneReader {
  func read(to delegate: any AvatarKit.SplatSceneReaderDelegate)
}
public enum ColorFormat : Swift.Sendable {
  case SRGB
  case RGB
  public static func == (a: AvatarKit.ColorFormat, b: AvatarKit.ColorFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ViewportDescriptor {
  public var viewport: Metal.MTLViewport
  public var projectionMatrix: simd.simd_float4x4
  public var viewMatrix: simd.simd_float4x4
  public var screenSize: Swift.SIMD2<Swift.Int>
  public init(viewport: Metal.MTLViewport, projectionMatrix: simd.simd_float4x4, viewMatrix: simd.simd_float4x4, screenSize: Swift.SIMD2<Swift.Int>)
}
public protocol UnsafeRawPointerConvertible {
  init(_ data: Swift.UnsafeRawPointer, from offset: Swift.Int, bigEndian: Swift.Bool)
  init(_ data: Swift.UnsafeRawPointer, bigEndian: Swift.Bool)
  static func array(_ data: Swift.UnsafeRawPointer, from offset: Swift.Int, count: Swift.Int, bigEndian: Swift.Bool) -> [Self]
  static func array(_ data: Swift.UnsafeRawPointer, count: Swift.Int, bigEndian: Swift.Bool) -> [Self]
}
extension Swift.BinaryInteger where Self : AvatarKit.EndianConvertible, Self : AvatarKit.UnsafeRawPointerConvertible {
  public init(_ data: Swift.UnsafeRawPointer, from offset: Swift.Int, bigEndian: Swift.Bool)
  public init(_ data: Swift.UnsafeRawPointer, bigEndian: Swift.Bool)
  public static func array(_ data: Swift.UnsafeRawPointer, from offset: Swift.Int, count: Swift.Int, bigEndian: Swift.Bool) -> [Self]
  public static func array(_ data: Swift.UnsafeRawPointer, count: Swift.Int, bigEndian: Swift.Bool) -> [Self]
}
extension Swift.BinaryFloatingPoint where Self : AvatarKit.BitPatternRepresentible, Self : AvatarKit.UnsafeRawPointerConvertible, Self.BitPattern : AvatarKit.EndianConvertible {
  public init(_ data: Swift.UnsafeRawPointer, from offset: Swift.Int, bigEndian: Swift.Bool)
  public init(_ data: Swift.UnsafeRawPointer, bigEndian: Swift.Bool)
  public static func array(_ data: Swift.UnsafeRawPointer, from offset: Swift.Int, count: Swift.Int, bigEndian: Swift.Bool) -> [Self]
  public static func array(_ data: Swift.UnsafeRawPointer, count: Swift.Int, bigEndian: Swift.Bool) -> [Self]
}
extension Swift.Int8 : AvatarKit.UnsafeRawPointerConvertible {
}
extension Swift.UInt8 : AvatarKit.UnsafeRawPointerConvertible {
}
extension Swift.Int16 : AvatarKit.UnsafeRawPointerConvertible {
}
extension Swift.UInt16 : AvatarKit.UnsafeRawPointerConvertible {
}
extension Swift.Int32 : AvatarKit.UnsafeRawPointerConvertible {
}
extension Swift.UInt32 : AvatarKit.UnsafeRawPointerConvertible {
}
extension Swift.Int64 : AvatarKit.UnsafeRawPointerConvertible {
}
extension Swift.UInt64 : AvatarKit.UnsafeRawPointerConvertible {
}
extension Swift.Float : AvatarKit.UnsafeRawPointerConvertible {
}
extension Swift.Double : AvatarKit.UnsafeRawPointerConvertible {
}
extension AvatarKit.AvatarController : Swift.Sendable {}
extension AvatarKit.AvatarSDK : Swift.Sendable {}
extension AvatarKit.Environment : Swift.Equatable {}
extension AvatarKit.Environment : Swift.Hashable {}
extension AvatarKit.Environment : Swift.RawRepresentable {}
extension AvatarKit.DrivingServiceMode : Swift.Equatable {}
extension AvatarKit.DrivingServiceMode : Swift.Hashable {}
extension AvatarKit.DrivingServiceMode : Swift.RawRepresentable {}
extension AvatarKit.LogLevel : Swift.Equatable {}
extension AvatarKit.LogLevel : Swift.Hashable {}
extension AvatarKit.LogLevel : Swift.RawRepresentable {}
extension AvatarKit.ConversationState : Swift.Equatable {}
extension AvatarKit.ConversationState : Swift.Hashable {}
extension AvatarKit.ConversationState : Swift.RawRepresentable {}
extension AvatarKit.AvatarError : Swift.Equatable {}
extension AvatarKit.AvatarError : Swift.Hashable {}
extension AvatarKit.AvatarError : Swift.RawRepresentable {}
extension AvatarKit.PLYHeader.Format : Swift.Hashable {}
extension AvatarKit.PLYHeader.Format : Swift.RawRepresentable {}
extension AvatarKit.PLYHeader.PrimitivePropertyType : Swift.Hashable {}
extension AvatarKit.ColorFormat : Swift.Equatable {}
extension AvatarKit.ColorFormat : Swift.Hashable {}
